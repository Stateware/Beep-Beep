// Copyright(c) 2015 Stateware Team -- Licensed GPL v3
// File Name: SimViewCar.cs
// Description: This is the source code for SimViewCar in SimView
// Dependencies: SimViewRoad.cs
// Additional Notes: N/A

using UnityEngine;
using System.Collections;

public class SimViewCar : MonoBehaviour
{
	// Car properties
	private float _maxSpeed = 5f;
	private float _speed = 0.0f;
	private float _angle;
	private float _reactionTime = 0.005f;
	private float _acce = 0.5f;
	private float _deac = -0.5f;
	private int _wait = 0;
	
	private Vector3 _origin;
	private Vector3 _destination;

	private int _currRoadIndex = 0;

    // Vector of roads generated by compiler
    public SimViewRoad[] roads;

    // Description: Initialize SimViewCar
    // PRE:         None
    // POST:        Car's initial position has been set and added to roadQueue
    void Start ()
    {
		GetComponent<SpriteRenderer>().color = new Color(Random.Range(0.5f, 1.0f), Random.Range(0.5f, 1.0f), Random.Range(0.5f, 1.0f));
		_origin = roads[_currRoadIndex].origin.transform.position + new Vector3(0, 0, -2);
		transform.position = _origin;
		_destination = roads[_currRoadIndex].destination.transform.position + new Vector3(0, 0, -2);
		_angle = GetAngle ();
		transform.eulerAngles = new Vector3 (0, 0, _angle);
		_speed = 0.0f;
		roads[_currRoadIndex].roadQueue.Add(this);
	}
	
	// Description: Update SimViewCar's position and speed
	// PRE:         Car is in current roadQueue
	// POST:        Speed is updated and remove and add car to new roadQueue
	void Update ()
    {
		if (Vector3.Distance(transform.position, _destination) < 0.1f && _currRoadIndex <= roads.Length)
		{
			_wait = 0;
			roads[_currRoadIndex].roadQueue.RemoveAt(0);
			_currRoadIndex++;

			if (_currRoadIndex < roads.Length)
			{
				roads[_currRoadIndex].roadQueue.Add (this);
				_origin = roads[_currRoadIndex].origin.transform.position + new Vector3(0, 0, -2);
				transform.position = _origin;
				_destination = roads[_currRoadIndex].destination.transform.position + new Vector3(0, 0, -2);
				_angle = GetAngle ();
				transform.eulerAngles = new Vector3 (0, 0, _angle);
			}
			else if (_currRoadIndex == roads.Length)
				Destroy (gameObject);
		}

		_speed = GetSpeed ();

		if (Vector3.Distance (transform.position, _destination) > 0.5f && Vector3.Distance (transform.position, _destination) < 0.7f && _wait < 50)
		{
			_wait++;
			_speed = 0.0f;
		}
		
		transform.position = Vector3.MoveTowards (transform.position, _destination, _speed * Time.deltaTime);
	}

    // Description: Get the updated speed of the car
    // PRE:         Car is in current roadQueue
    // POST:        Updated speed is calculated
	public float GetSpeed()
	{
		float speedA = 0.0f, speedB = 0.0f;

		speedA = _speed + 2.5f * _acce * _reactionTime * (1 - _speed / _maxSpeed) * Mathf.Sqrt (0.025f + _speed / _maxSpeed);
		
		float travelDistance = Vector3.Distance (transform.position, _origin);
		float roadLength = Vector3.Distance (_origin, _destination);
		float temp = _deac * _reactionTime;
		float prevLength = roadLength;

		if (_currRoadIndex < roads.Length && roads [_currRoadIndex].roadQueue.Count != 0)
		{
			int prevIndex = -1;
			for (int i = 0; i < roads[_currRoadIndex].roadQueue.Count; i++)
			{
				if (roads[_currRoadIndex].roadQueue[i] == this)
					prevIndex = i - 1;
			}
			if (prevIndex == -1)
			{
				prevLength = roadLength;
				speedB = temp + Mathf.Sqrt (temp * temp - _deac * (2 * (prevLength - travelDistance - 0.02f) - _speed * _reactionTime));
			}
			else
			{
				prevLength = Vector3.Distance(roads[_currRoadIndex].roadQueue[prevIndex].transform.position, _origin);
				speedB = temp + Mathf.Sqrt (temp * temp - _deac * (2 * (prevLength - travelDistance - 0.4f) - _speed * _reactionTime));
			}
		}
		
		return Mathf.Min (speedA, speedB);
	}

	// Description: Get the updated angle of the car
    // PRE:         Car is in current roadQueue
    // POST:        Updated angle is calculated
	public float GetAngle()
	{
		float temp;

		temp = Mathf.Abs (transform.position.y - _destination.y) / Mathf.Abs (transform.position.x - _destination.x);
		if ((transform.position.y - _destination.y) * (transform.position.x - _destination.x) < 0)
			temp *= -1;
		temp = Mathf.Rad2Deg * Mathf.Atan (temp);
		if (transform.position.x - _destination.x > 0)
			temp += 180;

		return temp;
	}
}

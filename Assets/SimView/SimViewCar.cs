// File Name: SimViewCar.cs
// Description: This is the source code for SimViewCar in SimView
// Dependencies: SimViewRoad.cs
// Additional Notes: N/A

using UnityEngine;
using System.Collections;

public class SimViewCar : MonoBehaviour {
	// Vector of roads generated by compiler
	public SimViewRoad[] roads;

	// Car properties
	private float _maxSpeed = 5f;
	private float _speed = 0.0f;
	private float _angle;
	private float _reactionTime = 0.005f;
	private float _acce = 0.5f;
	private float _deac = -0.5f;
	
	private Vector3 _origin;
	private Vector3 _destination;

	private int _currRoadIndex = 0;

	// Description: Initialize SimViewCar
    // PRE: None
	// POST: Car's initial position has been set and added to roadQueue
	void Start ()
    {
		_origin = roads[_currRoadIndex].origin.transform.position + new Vector3(0, 0, -2);
		transform.position = _origin;
		_destination = roads[_currRoadIndex].destination.transform.position + new Vector3(0, 0, -2);
		_angle = GetAngle ();
		transform.eulerAngles = new Vector3 (0, 0, _angle);
		_speed = 0.0f;
		roads[_currRoadIndex].roadQueue.Add(this);
	}
	
	// Description: Update SimViewCar's position and speed
	// PRE: Car is in current roadQueue
	// POST: Speed is updated and remove and add car to new roadQueue
	void Update ()
    {
		if (Vector3.Distance(transform.position, _destination) < 0.1f && _currRoadIndex <= roads.Length) {
			roads[_currRoadIndex].roadQueue.RemoveAt(0);
			_currRoadIndex++;
			if (_currRoadIndex < roads.Length) {
				roads[_currRoadIndex].roadQueue.Add (this);
				_origin = roads[_currRoadIndex].origin.transform.position + new Vector3(0, 0, -2);
				transform.position = _origin;
				_destination = roads[_currRoadIndex].destination.transform.position + new Vector3(0, 0, -2);
				_angle = GetAngle ();
				transform.eulerAngles = new Vector3 (0, 0, _angle);
				_speed = 0.0f;
			}
			else if (_currRoadIndex == roads.Length)
				Destroy (gameObject);
		}
		_speed = GetSpeed ();
		
		transform.position = Vector3.MoveTowards (transform.position, _destination, _speed * Time.deltaTime);
	}

    // Description: Get the updated speed of the car
    // PRE: Car is in current roadQueue
    // POST: Updated speed is calculated
	public float GetSpeed() {
		float speedA = _speed + 2.5f * _acce * _reactionTime * (1 - _speed / _maxSpeed) * Mathf.Sqrt (0.025f + _speed / _maxSpeed);
		
		float travelDistance = Vector3.Distance (transform.position, _origin);
		float roadLength = Vector3.Distance (_origin, _destination);
		float temp = _deac * _reactionTime;
		float speedB = temp + Mathf.Sqrt (temp * temp - _deac * (2 * (roadLength - travelDistance - 0.02f) - _speed * _reactionTime));
		
		return Mathf.Min (speedA, speedB);
	}

	// Description: Get the updated angle of the car
    // PRE: Car is in current roadQueue
    // POST: Updated angle is calculated
	public float GetAngle() {
		float temp;

		temp = Mathf.Abs (transform.position.y - _destination.y) / Mathf.Abs (transform.position.x - _destination.x);
		if ((transform.position.y - _destination.y) * (transform.position.x - _destination.x) < 0)
			temp *= -1;
		temp = Mathf.Rad2Deg * Mathf.Atan (temp);
		if (transform.position.x - _destination.x > 0)
			temp += 180;

		return temp;
	}
}
